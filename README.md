# Техническое задание

### В этом репозитории находятся два проекта: `dbus` (сервис) и `app` (приложение), оба независимы друг от друга.

Чтобы собрать каждый из проектов, необходимо в соответствующих папках инициализировать директорию build

```
cmake -B build/
```

Затем необходимо сбилдить сам проект и запустить его
```
cmake --build build/
./build/src/{project_name}
```
либо воспользоваться подгодовленным скриптом `run.sh` в каждой из директорий
```
bash run.sh
```

### Проект использует следующие зависимости:
```
libsdbus-c++-dev (sdbus-c++)
nlohmann-json3-dev (работа с json)
```

### Точкой входа в сервисе и в приложении является `main.cpp`

Перед запуском сервиса необходимо создать файл `confManagerApplication1.json` в `~/com.system.configurationManager/`, например, такой:
```
{
    "Timeout": 3,
    "TimeoutPhrase": "Hello world!"
}
```
или вызвать скрипт для инициализации конфигурационного файла:
```
bash init.sh
```


# Интерфейс взаимодействия сервиса и клиента (псевдокод):
```
interface InteractionInterface {
    const string name = "com.system.configurationManager.Application.Configuration";

    // methods
    func ChangeConfiguration(string key, sdbus::Variant value) -> void;
    func GetConfiguration() -> map<string, sdbus::Variant>;

    // signals
    signal configurationChanged(map<string, sdbus::Variant> conf);
}
```

После запуска сервиса, клиент может подключиться к сервису по сессионной шине и вызвать метод для получения результата или ожидать исходящий сигнал

# Принцип работы и использования

### Service
В самом начале сервис обходит все конфигурационные файлы в директории `~/com.system.configurationManager`, создаёт соответствующий sdbus объект для каждого и регистрирует все методы и сигналы интерфейса. После этого сервис уходит в цикл ожидания входящих запросов на исполнение методов на объектах.

### Application
Клиент подключается к сервису и создаёт прокси для взаимодействия с ним, регистрирует получение сигналов (в нашем случае только `configurationChanged`) и сперва вызывает метод `GetConfiguration()` для получения стартовой конфигурации (заодно можно убедиться, что соединение было установлено успешно). После этого создаётся thread для вывода заданной фразы раз в n секунд. Поток необходим, чтобы паралленьно с этим принимать сигналы в режиме ожидания (через `enterEventLoop()`).

### Отправка сигналов
Теперь в новом терминале можно вызвать команду (лежит в `send.sh`)
```
gdbus call -e -d {service} -o {object} -m {interface_method} {arguments...}
```
с помощью которой можно вызвать метод `ChangeConfiguration()`. В конце исполнения метода, сервис отправляет сигнал с обновлённой конфигурацией, который улавливается клиентом. 

_Примечание_:\
В качестве аргументов отправляется ключ и значение, но значение имеет тип Variant. Поэтому необходимы <> для строки и числа. Так как Timeout задаётся с помощью unsigned int, то это необходимо прописать в **явном** виде:
```
...ion.ChangeConfiguration "Timeout" <uint32 5>
```
Для удобства я добавил возможность принимать и просто интеджеры (`..."Timeout" <3>`), разумеется если конвертация возможна, но типизацию можно оставить строгой через флажок `INT_IS_UINT` в `dbus/src/interface.hpp`. Любое неправильное использование чего-либо в клиенте или сервисе сопровождается выкидыванием ошибки с описанием проблемы

Для более подробной демонстрации работы проекта я вывожу допольнительную информацию как в сервисе, так и в клиенте, что можно отключить через флажок в `debug_mode` в `dbus/src/interface.hpp` и `app/src/connect.hpp` соответственно


